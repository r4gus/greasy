use memmap::{Mmap};
use std::{
    ffi::CString,
};
use byteorder::{ByteOrder, LittleEndian};

#[derive(Debug)]
pub struct Fat {
    mem: Mmap,
    oem: String,                    // original equipment manufacturer label
    fat_type: String,               // FAT12, FAT16, FAT32
    fat_table_sectors: u32,         // Number of sectors per FAT table
    fat_table_entry_size: u8,       // Number of bytes per FAT table entry
    fat_table_count: u8,            // Number of FAT tables (usually: table + copy, e.g. 2)
    bytes_per_sector: u16,          // Number of Bytes per sector (512, 1024, ...)
    sectors_per_cluster: u8,        // Number of sectors per cluster (usually 2^n, for a small n)
    total_clusters: u32,            // Total number of clusters in cluster area
    reserved_sectors: u16,          // Number of sectors belonging to the reserved area
    total_sectors: u32,             // Total number of sectors of the volume
    offset_reserved_area: usize,    // Offset to the reserved area (in bytes)
    offset_fat_area: usize,         // Offset to the fat area (in bytes)
    offset_data_area: usize,        // Offset to the data area (in bytes)
    offset_root_dir: usize,         // Offset to the root directory (in bytes)
    offset_cluster_area: usize      // Offset to the cluster area (in bytes)
}

impl Fat {
    pub fn new(mem: Mmap) -> Fat {
        Fat {
            oem: "placeholder".to_string(),
            fat_table_sectors: match LittleEndian::read_u16(&mem[22..24]) {
                0 => LittleEndian::read_u32(&mem[36..40]),                  // 0 indicates FAT32
                _ => LittleEndian::read_u16(&mem[22..24]) as u32,
            },
            fat_type: match LittleEndian::read_u16(&mem[22..24]) {
                0 => "FAT32".to_string(),
                _ => "FAT16".to_string(),
            },
            fat_table_entry_size: 16,
            fat_table_count: mem[16] as u8,
            bytes_per_sector: LittleEndian::read_u16(&mem[11..13]),
            sectors_per_cluster: mem[13] as u8,
            reserved_sectors: LittleEndian::read_u16(&mem[14..16]),
            total_sectors: match LittleEndian::read_u16(&mem[19..21]) {
                0 => LittleEndian::read_u32(&mem[32..36]),
                _ => LittleEndian::read_u16(&mem[19..21]) as u32,
            },
            offset_reserved_area: 0,
            offset_fat_area: 0,
            offset_data_area: 0,
            offset_root_dir: 0,
            offset_cluster_area: 0,
            total_clusters: 0,
            mem: mem,
        }
    }

    pub fn info(&self) {
        println!("FILE SYSTEM INFORMATION
        --------------------------------
        File System Type: {}
        OEM Name: {}
        Vloume ID:
        Volume Label (Boot Sector):
        File System Type Label: {}

        Size
        --------------------------------
        Sector Size (in bytes): {}
        Cluster Size (in bytes): {}
        Cluster Range: 2 -

        File System Layout (in sectors)
        --------------------------------",
        self.fat_type,
         self.oem,
         self.fat_type,
         self.bytes_per_sector,
         self.bytes_per_sector * (self.sectors_per_cluster as u16));
    }
}
